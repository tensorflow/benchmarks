# Copyright 2019 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""PerfZero configs provided by user."""
from __future__ import print_function

import logging
import os


def add_parser_arguments(parser):
  """Add arguments to the parser intance."""
  parser.add_argument(
      '--force_update',
      action='store_true',
      help='If set, do git pull for dependent git repositories')
  parser.add_argument(
      '--gce_nvme_raid',
      default=None,
      type=str,
      help='If set to non-empty string, create raid 0 array with devices at /data')  # pylint: disable=line-too-long
  parser.add_argument(
      '--gcs_downloads',
      default=None,
      type=str,
      help='''The format is url_1;folder_name_1,url_2;folder_name_2,...
      Data will be copied from ${url} to /data/${folder_name}. ${folder_name} can be skipped if it is the same as the
      folder name in GCS url, which shortens the format to url_1,url_2,...''')
  parser.add_argument(
      '--git_repos',
      default=None,
      type=str,
      help='''Git repositories to checkout to local disk. The format is url_1;branch_1;hash_1,url_2;branch_2;hash_2,...
      Git repositories will be checked-out under directory path_to_perfzero/${workspace}/site-packages,
      where ${workspace} either defaults to 'workspace', or takes the value of the flag --workspace.
      branch and hash can be skipped if user wants to use the head of the master branch,
      which shortens the format to url_1,url_2,...''')
  parser.add_argument(
      '--benchmark_methods',
      action='append',
      type=str,
      help='''This string specifies the benchmark_method to be executed. The flag can be specified multiple times in which case
      the union of methods matched by these flags will be executed. The format can be module_path.class_name.method_name in which
      case the corresponding method is executed. The format can also be module_path.class_name.filter:regex_pattern, in which case all methods
      of the given class whose method name matches the given regular expression are executed.
      ''',
      default=[])
  parser.add_argument(
      '--ml_framework_build_label',
      type=str,
      help='A string that identified the machine learning framework build, e.g. nightly-gpu-build',
      default=None)
  parser.add_argument(
      '--execution_label',
      default=None,
      type=str,
      help='A string that identified the benchmark execution type, e.g. test, prod')  # pylint: disable=line-too-long
  parser.add_argument(
      '--platform_name',
      default=None,
      type=str,
      help='A string that identified the computing platform, e.g. gcp, aws')  # pylint: disable=line-too-long
  parser.add_argument(
      '--system_name',
      default=None,
      type=str,
      help='A string that identified the hardware system, e.g. n1-standard-64-8xV100')  # pylint: disable=line-too-long
  parser.add_argument(
      '--output_gcs_url',
      default=None,
      type=str,
      help='''If specified, log files generated by the benchmark execution will be uploaded to output_gcs_url/${execution_id},
      where ${execution_id} is a string that generated by PerfZero which uniquely identifies the execution of one benchmark method
      ''')
  parser.add_argument(
      '--bigquery_project_name',
      default=None,
      type=str,
      help='''If both --bigquery_project_name and --bigquery_dataset_table_name are specified, for each benchmark method, the benchmark
      summary will be uploaded to the specified bigquery table whose schema is defined in perfzero/scripts/create_big_table.txt.
      The value of each field can in turn be a json-formatted string. See README.md for example output.
      ''')
  parser.add_argument(
      '--bigquery_dataset_table_name',
      default=None,
      type=str,
      help='''If both --bigquery_project_name and --bigquery_dataset_table_name are specified, for each benchmark method, the benchmark
      summary will be uploaded to the specified bigquery table whose schema is defined in perfzero/scripts/create_big_table.txt.
      The value of each field can in turn be a json-formatted string. See README.md for example output.
      ''')
  parser.add_argument(
      '--python_path',
      default=None,
      type=str,
      help='''A common separated string of the format path_1,path_2,... For each ${path} specified in the string,
      path_to_perfzero/${workspace}/site-packages/${path} will be added to python path so that libraies downloaded by --git_repos can
      be loaded and executed.
      ''')
  parser.add_argument(
      '--workspace',
      default='workspace',
      type=str,
      help='''The log files, gcs token file and git repositories will be generated and downloaded under
      directory path_to_perfzero/${workspace}
      ''')


class PerfZeroConfig(object):
  """Creates and contains config for PerfZero."""

  def __init__(self, mode, flags=None):
    self.mode = mode
    self.flags = flags
    if mode == 'flags':
      self.gce_nvme_raid_str = flags.gce_nvme_raid
      self.gcs_downloads_str = flags.gcs_downloads
      self.git_repos_str = flags.git_repos
      self.benchmark_method_patterns = flags.benchmark_methods
      self.ml_framework_build_label_str = flags.ml_framework_build_label
      self.execution_label_str = flags.execution_label
      self.platform_name_str = flags.platform_name
      self.system_name_str = flags.system_name
      self.output_gcs_url_str = flags.output_gcs_url
      self.bigquery_project_name_str = flags.bigquery_project_name
      self.bigquery_dataset_table_name_str = flags.bigquery_dataset_table_name
      self.output_gcs_url_str = flags.output_gcs_url
      self.python_path_str = flags.python_path
      self.workspace = flags.workspace
      self.force_update = flags.force_update

      if not flags.benchmark_methods:
        logging.warn('No benchmark method is specified by --benchmark_methods')

      if flags.bigquery_project_name and not flags.bigquery_dataset_table_name:
        raise ValueError('--bigquery_project_name is specified but --bigquery_dataset_table_name is not')  # pylint: disable=line-too-long

      if not flags.bigquery_project_name and flags.bigquery_dataset_table_name:
        raise ValueError('--bigquery_dataset_table_name is specified but --bigquery_project_name is not')  # pylint: disable=line-too-long

  def get_env_vars(self):
    env_vars = {}
    for key in os.environ.keys():
      if key.startswith('PERFZERO_'):
        env_vars[key] = os.environ[key]
    return env_vars

  def get_flags(self):
    not_none_flags = {}
    for key in vars(self.flags):
      value = getattr(self.flags, key)
      if value is not None:
        not_none_flags[key] = value
    return not_none_flags

  def get_git_repos(self, site_packages_dir):
    """Parse git repository string."""
    git_repos = []
    if not self.git_repos_str:
      return git_repos

    for repo_entry in self.git_repos_str.split(','):
      parts = repo_entry.split(';')
      git_repo = {}
      git_repo['url'] = parts[0]
      # Assume the git url has format */{dir_name}.git
      git_repo['dir_name'] = parts[0].rsplit('/', 1)[-1].rsplit('.', 1)[0]
      git_repo['local_path'] = os.path.join(site_packages_dir,
                                            git_repo['dir_name'])
      if len(parts) >= 2:
        git_repo['branch'] = parts[1]
      if len(parts) >= 3:
        git_repo['git_hash'] = parts[2]
      git_repos.append(git_repo)

    return git_repos

  def get_gcs_downloads(self, data_dir):
    """Download data from GCS."""
    gcs_downloads = []
    if not self.gcs_downloads_str:
      return gcs_downloads

    for entry in self.gcs_downloads_str.split(','):
      gcs_download = {}
      # Canonicalize gcs url to remove trailing '/' and '*'
      if entry.endswith('*'):
        entry = entry[:-1]
      if entry.endswith('/'):
        entry = entry[:-1]

      if ';' in entry:
        gcs_download['gcs_url'] = entry.split(';')[0]
        gcs_download['local_path'] = os.path.join(data_dir, entry.split(';')[1])
      else:
        gcs_download['gcs_url'] = entry
        gcs_download['local_path'] = os.path.join(data_dir, os.path.basename(entry))  # pylint: disable=line-too-long
    gcs_downloads.append(gcs_download)

    return gcs_downloads

